package com.mason.ATD.recursive;

/**
 * 递归在数组中的运用
 *
 * @author ShiYong
 * @create 2022-04-12 15:13
 **/
public class ArrayRecursive {

    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 5, 6};
//        displayArray(arr, 0, arr.length - 1);
        dispalyArray03(arr, 0, arr.length - 1);

    }


    /**
     * 通过递归实现对数组的所有元素的显示
     *
     * @param array 传入的数组
     * @param first 数组的下标
     * @param last  数组的尾索引
     */
    public static void displayArray(int array[], int first, int last) {
        System.out.println(array[first] + "");
        if (first < last)
            displayArray(array, first + 1, last);
    }

    public static void dispalyArray02(int[] array, int first, int last) {
        if (first <= last) {
            dispalyArray02(array, first, last - 1);
            System.out.println(array[last] + " ");
        }
    }

    /**
     * 将数组分半实现对素组所有元素的显示
     * @param array
     * @param first
     * @param last
     */
    public static void dispalyArray03(int[] array, int first, int last) {
        if (first == last)
            System.out.print(array[first] + " ");
        else {
            int mid = (first + last) / 2;
            dispalyArray03(array, first, mid);
            dispalyArray03(array, mid + 1, last);
        }
    }

    /**
     * 递归问题总结：
     * 递归是将问题划分为更小的同样问题的问题求解过程,
     * 递归方法的定义必须含有能处理方法的输入(常常是一个形参)的逻辑,并导向不同的情形。
     * 其中的一个或多个情形是基础情形,或是终止情形,因为它们提供的是不再需要递归的答案。
     * 一个或多个情形中包括了方法的递归调用,通过求解“更小”版本的任务,而向基础情形迈进。
     * 对方法的每次调用,Java将方法形参和局部变量的值记录在活动记录中。记录被放到栈中,栈按时间顺序组织记录。最近入栈的记录是当前正在运行的方法的。
     * 这种方式下, Java可以暂停递归方法的执行,并用新的实参值重新执行它。
     * 递归方法处理一个数组时,常常将数组分成几部分。对方法的递归调用将处理数组的每个部分。
     * .处理结点链表的递归方法,需要一个指向链表首结点的引用作为形参。
     * .作为实现ADT 的组成部分的递归方法常常是私有的,因为要使用这个方法,需要对底层数据结构的了解。尽管这样的方法不适合作为ADT的操作,但它可以被实现某个操作的公有方法来调用。
     * .递推关系用函数自己来表示函数。可以使用递推关系来描述递归方法所做的事情。
     * 当递归方法的最后一个动作是递归调用时出现尾递归。这个递归调用执行的重复部分可用选代来完成。
     * 将尾递归方法转换为选代方法,通常是一个简单的过程。你可以使用栈替代递归来实现递归算法。这个栈模拟了程序栈的行为。
     */

    /**
     * 程序设计技巧：
     * 要写一个正确执行的递归方法，一般要遵守下列设计原则：
     *  1.必须给方法一个输入值，通常作为实参给出
     *  2.方法定义中必须含有使用了该输人值并能导向不同情形的逻辑。一般这样的逻辑包含一个if语句或一个switch语句。
     *  3.这些情形中的一个或多个,应该提供了不再需要递归的解决方案。这些是基础情形,或称终情形,
     *  4.一个或多个情形中必须包含对方法的递归调用。这些递归调用中应该含有一些步·骤,通过使用“更小”的参数,或者说由方法完成的“更小”版本的任务的求解,在某种意义上逐步导向；
     *  5.迭代方法包含一个循环。递归方法调用自己。虽然有些递归方法内含有循环并且调用自身,但如果你在递归方法内写一个while语句,要确定你不是要写一个if语句。
     *  6.不检查基础情形或丢掉了基础情形的递归方法,不会正常终止。这种情况称为无穷递归。
     *  7.不要使用在递归调用中重复求解同一问题的递归方案。
     *  8.递归调用太多会导致错误信息"stack overflow" (栈溢出)。这意味着活动记录的栈已经满了。本质上是方法使用了太多的内存。无穷递归或是大规模的问题容易引起这个错误
     *  如果递归方法没有得到想要的结果,则回答下列问题。任何否定的答案都可能帮助你找到错误。
     *  方法至少有一个形参或输入值吗?
     *  方法含有测试形参或输入值的语句,且能导向不同情形吗?.考虑了所有可能的情形吗?、
     *  至少有一种情形导致至少一次的递归调用吗?、
     *  这些递归调用涉及了更小的实参、更小的任务或者接近于解决方案的任务吗?
     *  如果这些递归调用产生或返回了正确的结果,那么方法产生或返回正确结果了吗？.
     *  是不是至少有一种情形即基础情形没有递归调用?、基础情形足够吗?.
     *  每个基础情形都能得到对应于这种情形的正确结果吗?如果方法返回一个值,则每种情形都返回了一个值吗?
     *
     */
}
